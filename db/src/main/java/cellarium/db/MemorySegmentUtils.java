package cellarium.db;


import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.ValueLayout;
import java.util.Collection;

import cellarium.db.converter.Converter;
import cellarium.db.converter.ConverterFactory;
import cellarium.db.database.types.AValue;
import cellarium.db.database.types.BooleanValue;
import cellarium.db.database.types.DataType;
import cellarium.db.database.types.IntegerValue;
import cellarium.db.database.types.LongValue;
import cellarium.db.database.types.StringValue;

public class MemorySegmentUtils {
    public static final Arena ARENA_OF_AUTO = Arena.ofAuto();
    public static final byte BYTE_SIZE = 1;

    private MemorySegmentUtils() {
    }

    public static String memorySegmentToString(MemorySegment data) {
        if (data == null) {
            return null;
        }

        return data.getUtf8String(0);
    }

    public static MemorySegment stringToMemorySegment(String data) {
        if (data == null) {
            return null;
        }

        return ARENA_OF_AUTO.allocateUtf8String(data);
    }

    public static AValue<?> toValue(DataType dataType, MemorySegment value) {
        final Converter<Object, MemorySegment> converter = ConverterFactory.getConverter(dataType);

        return switch (dataType) {
            case INTEGER -> IntegerValue.of((Integer) converter.convertBack(value));
            case LONG -> LongValue.of((Long) converter.convertBack(value));
            case BOOLEAN -> BooleanValue.of((Boolean) converter.convertBack(value));
            case STRING -> StringValue.of((String) converter.convertBack(value));
            default -> throw new IllegalStateException("Unsupported data type");
        };
    }

    public static MemorySegment sliceFirstDbValue(MemorySegment value) {
        final byte typeId = value.get(ValueLayout.JAVA_BYTE, 0);
        final DataType dataType = DataType.getById(typeId);
        int sizeBytes = dataType.getSizeBytes();
        if (sizeBytes == AValue.UNDEFINED_SIZE_BYTES) {
            sizeBytes = value.get(ValueLayout.JAVA_INT_UNALIGNED, BYTE_SIZE);
        }

        return value.asSlice(0, sizeBytes + BYTE_SIZE + (sizeBytes == AValue.UNDEFINED_SIZE_BYTES ? Integer.BYTES : 0));
    }

    /**
     * !!! Java doc is generated by ChatGPT !!!
     * <p>
     * Performs a binary search on a memory segment to find the index of a given key within an array of offsets.
     * If the key is found, the index of the key is returned. If the key is not found, the method returns
     * the negative insertion point - 1 (i.e., -left - 1) to indicate where the key would be inserted to maintain sorted order.
     *
     * @param indexSegment A MemorySegment representing a segment of memory where the keys are stored.
     *                     This segment contains the actual data referenced by the offsets in indexOffsets.
     * @param indexOffsets An array of long values representing offsets within the indexSegment where keys begin.
     *                     This array must be sorted in ascending order according to the keys it references.
     * @param key          A MemorySegment representing the key to search for within the indexSegment.
     *                     This is the value being searched for within the keys referenced by indexOffsets.
     * @return The index of the key within the indexOffsets array if found. If the key is not found, returns
     * the negative index - 1 where the key would be inserted to maintain the order (i.e., -insertionPoint - 1).
     * For example, if the return value is -5, the key would be inserted at index 4 to maintain order.
     * <p>
     */
    public static int findIndexOfKey(MemorySegment indexSegment, long[] indexOffsets, MemorySegment key) {
        int left = 0;
        int right = indexOffsets.length - 1;

        while (left <= right) {
            final int i = (left + right) >>> 1;
            final MemorySegment current = MemorySegmentUtils.sliceFirstDbValue(indexSegment.asSlice(indexOffsets[i]));
            final int compare = MemorySegmentComparator.INSTANCE.compare(current, key);
            if (compare > 0) {
                right = i - 1;
                continue;
            }

            if (compare < 0) {
                left = i + 1;
                continue;
            }

            return i;
        }

        return -left;
    }

    public static long calculateMemorySegmentsSizeBytes(MemorySegment... segments) {
        long size = 0;
        for (MemorySegment s : segments) {
            size += s.byteSize();
        }

        return size;
    }

    public static long calculateMemorySegmentsSizeBytes(Collection<MemorySegment> segments) {
        return segments.stream().mapToLong(MemorySegment::byteSize).sum();
    }
}
